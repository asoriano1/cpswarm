#include <ros/ros.h>
#include <ros/console.h>
#include <move_base_msgs/MoveBaseAction.h>
#include <nav_msgs/OccupancyGrid.h>
#include <geometry_msgs/PoseWithCovarianceStamped.h>
#include <sensor_msgs/LaserScan.h>
#include <actionlib/client/simple_action_client.h>
#include <laser_geometry/laser_geometry.h>
#include <array>
#include <math.h>
#include <fstream>
#include <unordered_set>

/**
 * Reading candidate representation generated by Frevo.
 * TODO: Wrap as ROS class.
 */
#include "candidate.c"

using namespace std;

/**
 * Constant Pi.
 */
#define PI 3.14159265

/**
 * Agent position.
 */
geometry_msgs::Pose pose;

/**
 * Valid flag for agent position.
 */
bool pose_valid = false;

/**
 * Grid map.
 */
nav_msgs::OccupancyGrid grid_map;

/**
 * Valid flag for map.
 */
bool map_valid = false;

/**
 * Namespace of this robot.
 */
string ns;

/**
 * Log file.
 */
string log_file;

/**
 * Valid flag for log file.
 */
bool log_valid = false;

/**
 * File stream for log file.
 */
fstream fs_log;

/**
 * Simulated discrete time step.
 */
int step;

/**
 * Distance (in x and y direction) that the agent can move in each step (in meters).
 */
double step_size;

/**
 * Closest emergency exit.
 */
double closest_dist;

/**
 * Laser scan data.
 */
sensor_msgs::LaserScan scan;

/**
 * Valid flag for laser scan data.
 */
bool scan_valid = false;

/**
 * Total number of agents in the simulation.
 */
int agents;

/**
 * Whether the agent escaped.
 */
bool escaped;

/**
 * Maximum number of simulation steps.
 */
int max_steps;

/**
 * X and y offset to which the agent moves.
 */
int dx,dy;

/**
 * List of emergency exits.
 */
list<pair<double,double>> exits;

/**
 * Emergency exit list iterator.
 */
list<pair<double,double>>::iterator it;

/**
 * The allowed distance between two points to be still considered at the same location.
 */
double epsilon;

/**
 * Send a goal to the agent's move base node.
 * It moves the robot by the given parameters,
 * using an action client.
 * @param int dx: horizontal displacement of agent.
 * @param int dy: vertical displacement of agent.
 * @return bool: success of movement.
 */
bool move(int dx, int dy)
{
	ROS_INFO("Moving...");
    actionlib::SimpleActionClient < move_base_msgs::MoveBaseAction> ac("move_base", true);
    while (!ac.waitForServer(ros::Duration(10.0)))
        ROS_DEBUG_ONCE("Waiting for action server.");

    move_base_msgs::MoveBaseGoal goal_msgs;
    std::string ns_clean = ns.substr(ns.find("/")+1); 

    goal_msgs.target_pose.header.seq += 1;
    goal_msgs.target_pose.header.stamp = ros::Time::now();    
    //goal_msgs.target_pose.header.frame_id = "/" + ns + "/map";
    goal_msgs.target_pose.header.frame_id = ns_clean + "_map";
    //goal_msgs.target_pose.header.frame_id = ns_clean.append("_map");
    goal_msgs.target_pose.pose.position.x = round(pose.position.x) + dx * step_size;
    goal_msgs.target_pose.pose.position.y = round(pose.position.y) + dy * step_size;
    goal_msgs.target_pose.pose.position.z = 0;
    goal_msgs.target_pose.pose.orientation = pose.orientation;
    
    ROS_DEBUG("Move agent to (%.2f,%.2f).", goal_msgs.target_pose.pose.position.x, goal_msgs.target_pose.pose.position.y);
	
    ac.sendGoal(goal_msgs);
    ac.waitForResult(ros::Duration(7.0));

    while (ac.getState() == actionlib::SimpleClientGoalState::PENDING)
        ROS_DEBUG_ONCE("Action client is PENDING.");

    while (ac.getState() == actionlib::SimpleClientGoalState::ACTIVE)
        ROS_DEBUG_ONCE("Action client is ACTIVE.");

    while (ac.getState() != actionlib::SimpleClientGoalState::SUCCEEDED){
        if (ac.getState() == actionlib::SimpleClientGoalState::ABORTED){
            ROS_ERROR("Action client ABORTED!");
            return false;
            break;
        }
    }

    ROS_DEBUG("Reached goal (%.2f,%.2f).", goal_msgs.target_pose.pose.position.x, goal_msgs.target_pose.pose.position.y);
    return true;
}

/**
 * Initialize the log file.
 */
void initLog()
{
    // log file path
    log_file = log_file.append("/" + ns + ".log");
    log_valid = true;
    ROS_INFO("Logging to %s", log_file.c_str());
    
    // write log file header
    fs_log.open(log_file.c_str(), fstream::trunc | fstream::out);
    fs_log << "# emergency exit example" << endl;
    fs_log << "#" << endl << endl;
    fs_log << "# step" << "\t" << "dist" << endl;
    fs_log.close();
}

/**
 * Write current status to log file.
 * @return bool: Returns false if the log file has not been initialized yet.
 */
bool log()
{
    if(log_valid == false){
        ROS_ERROR("No valid log file!");
        return false;
    }
    
    fs_log.open(log_file.c_str(), fstream::app | fstream::out);
    fs_log << step << "\t" << closest_dist << endl;
    fs_log.close();
    
    return true;
}

/**
 * Calculate the eucledian distance between two coordinates.
 * @param pair<double,double> c1: first coordinate.
 * @param pair<double,double> c2: second coordinate.
 * @return double: the eucledian distance between the coordinates.
 */
double distance(pair<double,double> c1, pair<double,double> c2)
{
    return hypot(c2.first-c1.first, c2.second-c1.second);
}

/**
 * Sense the occupancy of a cell with given offset from the robots position.
 * @param int dx: x offset of the cell
 * @param int dy: y offset of the cell.
 * @return int: occupancy of cell, 0=free, 1=occupied.
 */
int sense(int dx, int dy)
{
    // coordinate variables
    int x, y, idx;
    
    // compute robot angle
    tf::Pose orientation;
    tf::poseMsgToTF(pose, orientation);
    double a_robot = tf::getYaw(orientation.getRotation());
    ROS_DEBUG("Robot angle %.2f", a_robot);     
   
    // compute laser scan angle
    double a = atan2(dy, dx); // absolute angle from positive x-axis (world coordinates)
    a -= a_robot; // shift angle by robot orientation (robot coordinates)
    if(a > PI) // fix angle overflow
        a -= 2*PI;
    
    // compute laser scan index
    //idx = (scan.ranges.size()/2)-(a*180/PI);
    //idx = scan.ranges.size()-(scan.ranges.size()/2)+(a*180/PI);
    idx = scan.ranges.size()-(scan.ranges.size()/2)-(a*180/PI);
    
    if(idx<0 || idx>=scan.ranges.size()){
		ROS_INFO("FAIL! Laser data at (%d, %d), angle %.2f, index %d: %.2f. size: %d ", dx, dy, a, idx, scan.ranges[idx], scan.ranges.size());
		return 1;
    }
    // read sensed laser scan data
    double sensor = scan.ranges[idx];
    ROS_DEBUG("Laser data at (%d, %d), angle %.2f, index %d: %.2f.", dx, dy, a, idx, sensor);
    ROS_INFO("Laser data at (%d, %d), angle %.2f, index %d: %.2f. size: %d ", dx, dy, a, idx, sensor, scan.ranges.size());
    
    // convert to occupancy
    int occupancy;
    if(sensor > step_size)
        occupancy = 0; // cell is free
    else
        occupancy = 1; // cell is occupied
    
    return occupancy;
}

/**
 * Execute one simulation step.
 */
void simStep()
{
    // next step
    ++step;
    
    // maximum number of steps reached, stop searching for exit
    if(step > max_steps)
        return;
    
    ROS_INFO("Simulating step %d.", step);

    // sensor inputs
    // 1: free
    // 0: occupied
    // 0, 1: x/y offset to nearest exit
    // 2..5: occupancy of neighborhood
    float in[6];
    
    // find closest exit
    closest_dist = 0;
    pair<double,double> closest_exit;
    for(it=exits.begin(); it!=exits.end(); ++it){
        double dist = distance(*it, make_pair(pose.position.x, pose.position.y));
        if(dist < closest_dist || closest_dist == 0){
            closest_dist = dist;
            closest_exit = *it;
        }
    }
    in[0] = round(closest_exit.first - pose.position.x);//-1
    in[1] = round(closest_exit.second - pose.position.y);
    ROS_DEBUG("Closest emergency exit at (%.2f,%.2f), distance %.2f.", closest_exit.first, closest_exit.second, closest_dist);
	ROS_INFO("Closest emergency exit at (%.2f,%.2f), distance %.2f.", closest_exit.first, closest_exit.second, closest_dist);

    // agent reached exit
    if(closest_dist < epsilon){
        escaped = true;
        ROS_INFO("Agent escaped.");
        return;
    }
    
    // sense neighborhood
    in[2] = (float) sense(1, 0);
    in[3] = (float) sense(0, 1);
    in[4] = (float) sense(-1, 0);
    in[5] = (float) sense(0, -1);
    ROS_DEBUG("NN input: %.2f, %.2f, %.2f, %.2f, %.2f, %.2f", in[0], in[1], in[2], in[3], in[4], in[5]);
    ROS_INFO("NN input: %.2f, %.2f, %.2f, %.2f, %.2f, %.2f", in[0], in[1], in[2], in[3], in[4], in[5]);
    
    // use nn to get actuator output
    Result out = getOutput(in, 6);
    ROS_DEBUG("NN output: %.2f, %.2f", out.output[0], out.output[1]);
    ROS_INFO("NN output: %.2f, %.2f", out.output[0], out.output[1]);
    dx = (int) round(out.output[0] * 2 - 1);
    dy = 0;
    if(dx == 0) // only go in one direction
        dy = (int) round(out.output[1] * 2 - 1);
    
    // invalid movement parameters
    if((dx != 0 || (dy != 1 && dy != -1)) && (dy != 0 || (dx != 1 && dx != -1))){
        ROS_ERROR("Step %d: invalid direction (%d, %d)!", step, dx, dy);
        ros::Duration(0.5).sleep();
    }
    
    // target cell is not free
    else if(sense(dx, dy) == 1){
        ROS_ERROR("Step %d: could not move agent by (%d, %d)! Cell is not free!", step, dx, dy);
        ros::Duration(0.5).sleep();
    }
    
    // movement failed for some other reason
    else if(move(dx, dy) == false){
        ROS_ERROR("Step %d: could not move agent by (%d, %d)!", step, dx, dy);
        ros::Duration(0.5).sleep();
    }
    
    // movement successful
    else
        ROS_INFO("Step %d: move agent by (%d, %d).", step, dx, dy);
    
    // write current status to log file
    log();
}

/**
 * Callback function to receive agent position.
 * @param const geometry_msgs::PoseWithCovarianceStamped newPose: the agents position.
 */
void poseUpdate(const geometry_msgs::PoseWithCovarianceStamped new_pose)
{
    pose = new_pose.pose.pose;
    pose_valid = true;
    ROS_DEBUG_ONCE("Got valid position, agent at (%.2f,%.2f).", pose.position.x, pose.position.y);
}

/**
 * Callback function to receive map.
 * @param const nav_msgs::OccupancyGrid new_grid_map: the map.
 */
void mapUpdate(const nav_msgs::OccupancyGrid new_grid_map)
{
    grid_map = new_grid_map;
    map_valid = true;
    ROS_DEBUG("Got valid map of size %.2f x %.2f.", grid_map.info.width, grid_map.info.height);
}

/**
 * Callback function to receive laser scan data.
 * @param const sensor_msgs::LaserScan::ConstPtr scan: the laser scan.
 */
void laserUpdate(const sensor_msgs::LaserScan::ConstPtr scan_in)
{
    scan = *scan_in.get();
    scan_valid = true;
}

/**
 * Main function, entrypoint.
 * @param int arc: number of passed arguments.
 * @param char** argv: the passed arguments.
 * @return int: exit code of the program.
 */
int main(int argc, char** argv)
{
    ros::init(argc, argv, "emergency_exit");

    ros::NodeHandle nh("~");
    
    // set logger level
    if(ros::console::set_logger_level(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Info)){
        ros::console::notifyLoggerLevelsChanged();
    }
    else{
        ROS_ERROR("Could not set logger level!");
    }
    
    // get namespace
    ns = ros::this_node::getNamespace();
    ns.erase(ns.begin(), ns.begin()+1);
    
    // read number of participating agents
    nh.param<int>("agents", agents, 1);
    
    // subscribe to amcl_pose topic to get agent position
    ros::Subscriber pose_sub = nh.subscribe("/" + ns + "/amcl_pose", 1, poseUpdate);
    
    // subscribe to map topic to get grid map of environment
    ros::Subscriber map_sub = nh.subscribe("/" + ns + "/map", 1, mapUpdate);
    
    // subscribe to base_scan topic to get laser scanner data
    ros::Subscriber laser_sub = nh.subscribe("/" + ns + "/base_scan", 1, laserUpdate);
    
    // initialize log file
    nh.param<string>("log_path", log_file, "");
    initLog();
    
    // read maximum number of simuation steps
    nh.param<int>("steps", max_steps, 100);
    step = 0;
    
    // read coordinates of emergency exits
    int num_exits;
    nh.param<int>("exits", num_exits, 0);
    ROS_DEBUG("There are %d emergency exits.", num_exits);
    for(int i=0; i<num_exits; ++i){
        stringstream exit_s;
        exit_s << "exit_" << i;
        vector<double> exit_i;
        nh.getParam(exit_s.str(), exit_i);
        ROS_DEBUG("Exit %d at (%.2f,%.2f).", i, exit_i[0], exit_i[1]);
        exits.push_back(make_pair(exit_i[0], exit_i[1]));
    }
    if(exits.size() == 0){
        ROS_FATAL("There are no emergency exits, terminating now!");
        return 0;
    }
    
    // read epsilon which is the allowed distance between two points
    // to be still considered at the same location
    nh.param<double>("epsilon", epsilon, 0.1);
    
    // read step size which is the distance the agent travels in each simulation step
    nh.param<double>("step_size", step_size, 1);
    
    // true when agent found an exit
    escaped = false;
        
    // frequency of loop
    double rate = 10; // Hz
    ros::Rate loop_rate(rate);
    
    // wait to get a valid agent position
    while(pose_valid == false){
        ROS_DEBUG_ONCE("Waiting for valid pose.");
        loop_rate.sleep();
        ros::spinOnce();
    }
    
    // wait to get a valid map
    while(map_valid == false){
        ROS_DEBUG_ONCE("Waiting for valid map.");
        loop_rate.sleep();
        ros::spinOnce();
    }
    
    // wait to get a valid laser scan
    while(scan_valid == false){
        ROS_DEBUG_ONCE("Waiting for valid laser scan.");
        loop_rate.sleep();
        ros::spinOnce();
    }
    
    // wait for all agents
    ros::WallDuration(2).sleep();
    ros::spinOnce();

    // main loop, run simulation step by step
    while(ros::ok() && escaped == false && step <= max_steps){
        // get updates from subscriptions
        ros::spinOnce();
        
        // simulate one time step
        simStep();
    }
        
    // write current status to log file
    log();
    
    // keep moving agent so it does not block the exit for other agents
    while(ros::ok() && escaped == true && step <= max_steps){
        // get updates from subscriptions
        ros::spinOnce();
        
        // move agent
        ROS_DEBUG("Step %d: move agent by (%d, %d).", step, dx, dy);
        move(dx, dy);
        
        // sleep for 1/rate seconds
        loop_rate.sleep();
        
        // next step
        ++step;
    }

    return 0;
}

